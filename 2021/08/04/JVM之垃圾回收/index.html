<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.sunyh512.cn","root":"/","images":"/images","scheme":"Gemini","version":"8.5.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>
<meta name="description" content="嗯，垃圾回收。。">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM之垃圾回收">
<meta property="og:url" content="http://blog.sunyh512.cn/2021/08/04/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/index.html">
<meta property="og:site_name" content="Ghuilrei&#39;s Blog">
<meta property="og:description" content="嗯，垃圾回收。。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://img.sunyh512.cn/img/20210714194116.png">
<meta property="og:image" content="http://img.sunyh512.cn/img/20210714194607.png">
<meta property="og:image" content="http://img.sunyh512.cn/img/20210714194116.png">
<meta property="og:image" content="http://img.sunyh512.cn/img/20210731193313.png">
<meta property="og:image" content="http://img.sunyh512.cn/img/20210731193335.png">
<meta property="og:image" content="http://img.sunyh512.cn/img/20210802155918.png">
<meta property="og:image" content="http://img.sunyh512.cn/img/20210731194302.png">
<meta property="article:published_time" content="2021-08-04T09:33:13.000Z">
<meta property="article:modified_time" content="2021-08-30T09:56:25.329Z">
<meta property="article:author" content="Ghuilrei">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://img.sunyh512.cn/img/20210714194116.png">


<link rel="canonical" href="http://blog.sunyh512.cn/2021/08/04/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://blog.sunyh512.cn/2021/08/04/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/","path":"2021/08/04/JVM之垃圾回收/","title":"JVM之垃圾回收"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>JVM之垃圾回收 | Ghuilrei's Blog</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Ghuilrei's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
        <li class="menu-item menu-item-schedule"><a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E5%9B%9E%E6%94%B6"><span class="nav-number">1.</span> <span class="nav-text">判断对象是否可回收</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="nav-number">1.1.</span> <span class="nav-text">引用计数法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90"><span class="nav-number">1.2.</span> <span class="nav-text">可达性分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E7%94%A8%E5%81%9AGC%E6%A0%B9%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.2.1.</span> <span class="nav-text">可用做GC根的对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E5%BC%95%E7%94%A8%E5%88%86%E7%B1%BB"><span class="nav-number">1.3.</span> <span class="nav-text">Java引用分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8"><span class="nav-number">1.3.1.</span> <span class="nav-text">强引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8"><span class="nav-number">1.3.2.</span> <span class="nav-text">软引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="nav-number">1.3.3.</span> <span class="nav-text">弱引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8"><span class="nav-number">1.3.4.</span> <span class="nav-text">虚引用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#finalize-%E6%96%B9%E6%B3%95"><span class="nav-number">1.4.</span> <span class="nav-text">finalize()方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%94%B6%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="nav-number">1.5.</span> <span class="nav-text">回收方法区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E6%94%B6%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%89%8D%E6%8F%90%E6%9D%A1%E4%BB%B6"><span class="nav-number">1.5.1.</span> <span class="nav-text">回收类型的前提条件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">垃圾回收算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="nav-number">2.1.</span> <span class="nav-text">标记-清除算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="nav-number">2.2.</span> <span class="nav-text">标记-整理算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="nav-number">2.3.</span> <span class="nav-text">标记-复制算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D"><span class="nav-number">2.3.1.</span> <span class="nav-text">内存分配担保</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">3.</span> <span class="nav-text">垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E8%AF%A6%E8%A7%A3"><span class="nav-number">3.1.</span> <span class="nav-text">垃圾收集器详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Serial"><span class="nav-number">3.1.1.</span> <span class="nav-text">Serial</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ParNew"><span class="nav-number">3.1.2.</span> <span class="nav-text">ParNew</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Parallel-Scavenge"><span class="nav-number">3.1.3.</span> <span class="nav-text">Parallel Scavenge</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Serial-Old"><span class="nav-number">3.1.4.</span> <span class="nav-text">Serial Old</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CMS"><span class="nav-number">3.1.5.</span> <span class="nav-text">CMS</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%9B%E4%B8%AA%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="nav-number">3.1.5.1.</span> <span class="nav-text">四个步骤：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#G1"><span class="nav-number">3.1.6.</span> <span class="nav-text">G1</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%9B%E4%B8%AA%E6%AD%A5%E9%AA%A4"><span class="nav-number">3.1.6.1.</span> <span class="nav-text">四个步骤</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ZGC"><span class="nav-number">3.1.7.</span> <span class="nav-text">ZGC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Shenandoah"><span class="nav-number">3.1.8.</span> <span class="nav-text">Shenandoah</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="nav-number">3.1.8.1.</span> <span class="nav-text">步骤：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Brooks-Pointer-%E8%BD%AC%E5%8F%91%E6%8C%87%E9%92%88"><span class="nav-number">3.1.8.2.</span> <span class="nav-text">Brooks Pointer 转发指针</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CMS%E5%92%8CG1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.2.</span> <span class="nav-text">CMS和G1的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0"><span class="nav-number">3.3.</span> <span class="nav-text">三色标记</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="nav-number">4.</span> <span class="nav-text">内存溢出与内存泄露</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB"><span class="nav-number">4.1.</span> <span class="nav-text">内存泄漏和内存溢出区别与联系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">4.2.</span> <span class="nav-text">内存泄露的原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">4.3.</span> <span class="nav-text">内存溢出的原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="nav-number">4.4.</span> <span class="nav-text">常见的内存溢出</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%8F%8A%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5"><span class="nav-number">5.</span> <span class="nav-text">内存分配及回收策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%E5%A6%82%E4%BD%95%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="nav-number">5.1.</span> <span class="nav-text">新生代如何进入老年代</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ghuilrei"
      src="http://img.sunyh512.cn/img/20210803143027.jpeg">
  <p class="site-author-name" itemprop="name">Ghuilrei</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



          </div>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://blog.sunyh512.cn/2021/08/04/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.sunyh512.cn/img/20210803143027.jpeg">
      <meta itemprop="name" content="Ghuilrei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ghuilrei's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JVM之垃圾回收
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-04 17:33:13" itemprop="dateCreated datePublished" datetime="2021-08-04T17:33:13+08:00">2021-08-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-08-30 17:56:25" itemprop="dateModified" datetime="2021-08-30T17:56:25+08:00">2021-08-30</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E4%BD%93%E7%B3%BB/" itemprop="url" rel="index"><span itemprop="name">Java体系</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E4%BD%93%E7%B3%BB/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>嗯，垃圾回收。。</p>
<span id="more"></span>

<h2 id="判断对象是否可回收"><a href="#判断对象是否可回收" class="headerlink" title="判断对象是否可回收"></a>判断对象是否可回收</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>加一个计数器，有引用就$+1$，失效就$-1$，为0就回收</p>
<ul>
<li><p>  优点：实现简单</p>
</li>
<li><p>  缺点：当遇到循环引用时，难以解决</p>
</li>
</ul>
<h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><p>通过一系列称为<code>GC Roots</code>的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”。</p>
<p>如果某个对象到<code>GC Roots</code>间没有任何引用链相连，或者用图论的话来说就是从<code>GC Roots</code>到这个对象不可达时，则证明此对象是不可能再被使用的。</p>
<h4 id="可用做GC根的对象"><a href="#可用做GC根的对象" class="headerlink" title="可用做GC根的对象"></a>可用做GC根的对象</h4><ul>
<li>  虚拟机栈中的对象</li>
<li>  在方法区中静态属性引用的对象</li>
<li>  在方法区中常量引用的对象</li>
<li>  在本地方法栈中JNI引用的对象</li>
<li>  Java虚拟机内部的引用</li>
<li>  同步锁持有的对象</li>
<li>  反映Java虚拟机内部情况的JMXBean、JVMTI中注册的会笑、本地代码缓存等</li>
</ul>
<h3 id="Java引用分类"><a href="#Java引用分类" class="headerlink" title="Java引用分类"></a>Java引用分类</h3><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似<code>Object obj=new Object()</code>这种引用关系。</p>
<p>无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</p>
<h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>（常用于缓存）</p>
<p>用来描述一些还有用，但非必须的对象。</p>
<p>只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p>
<p>在JDK1.2版之后提供了SoftReference类来实现软引用。</p>
<h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>（也常用于缓存）</p>
<p>用来描述那些非必须对象</p>
<p>它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。</p>
<p>当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</p>
<p>在JDK 1.2版之后提供了WeakReference类来实现弱引用。</p>
<h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>也称为“幽灵引用”或者“幻影引用”</p>
<p>它是最弱的一种引用关系。</p>
<p>一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。</p>
<p>为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。</p>
<p>在JDK 1.2版之后提供了PhantomReference类来实现虚引用。</p>
<p><em>问题：分别找出强软弱虚的例子或在Java中本身就使用的例子</em></p>
<h3 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a>finalize()方法</h3><p>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记。</p>
<p>随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。</p>
<p>假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。</p>
<p>如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的 队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize() 方法。</p>
<p><strong>任何一个对象的finalize()方法都只会被系统自动调用一次</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.对象可以在被GC时自我拯救。</span></span><br><span class="line"><span class="comment"> * 2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Yes, I&#x27;m still alive&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;finalize method executed!&quot;</span>);</span><br><span class="line">        Test4.SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> Test4();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象第一次成功拯救自己</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为finalize优先级很低，所有暂停0.5s等待一下</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;No, I&#x27;m dead :（&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象再次尝试拯救自己，但是这次就拯救失败了</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为finalize优先级很低，所有暂停0.5s等待一下</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;No, I&#x27;m dead :（&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p>主要回收：</p>
<ul>
<li>  废弃的常量</li>
<li>  不再使用的类型</li>
</ul>
<h4 id="回收类型的前提条件"><a href="#回收类型的前提条件" class="headerlink" title="回收类型的前提条件"></a>回收类型的前提条件</h4><ul>
<li>  该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</li>
<li>  加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</li>
<li>  该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的<strong>仅仅是“被允许”</strong>，而并不是和对象一样，没有引用了就必然会回收。</p>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象。也可以反过来，标记存活的对象，统一回收所有未被标记的对象。</p>
<ul>
<li><p>缺点：</p>
<ul>
<li><p>  执行效率不稳定</p>
</li>
<li><p>  内存空间的碎片化问题</p>
</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li>  实现简单，高效</li>
</ul>
</li>
</ul>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>标记过程与“标记-清除算法”一样，但之后不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。</p>
<ul>
<li><p>优点：</p>
<ul>
<li>  内存比较整齐，不会有碎片化的问题</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>  移动对象带来的开销很大</li>
</ul>
</li>
</ul>
<h3 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h3><p>它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着 的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p>
<p>多数对象都是存活的情况：</p>
<p>​    算法将会产生大量的内存间复制的开销。</p>
<p>多数对象都是可回收的情况：</p>
<p>​    算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。</p>
<ul>
<li><p>优点：</p>
<ul>
<li>  实现简单，高效</li>
<li>  没有空间碎片</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>  空间利用率比较低，可用内存缩小为了原来的一半</li>
</ul>
</li>
</ul>
<p>优化：HotSpot虚拟机默认Eden和Survivor的大小比例是$8:1:1$，也即每次新生代中可用内存空间为整个新生代容量的90%，Survivor不够时，老年代<a href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D">内存分配担保</a>。</p>
<h4 id="内存分配担保"><a href="#内存分配担保" class="headerlink" title="内存分配担保"></a>内存分配担保</h4><p>在发生Minor GC之前，虚拟机会先检查年老代剩余的连续空间是否大于新生代所有对象的总空间，如果条件成立，那么Minor GC可以确保是安全的。</p>
<p>如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。</p>
<p>如果允许，那么会继续检查年老代最大可用连续空间是否大于历次晋升到年老代对象的平均大小，</p>
<p>​    如果大于，将尝试进行一次Minor GC,尽管这次Minor GC是有风险的。</p>
<p>​    如果小于，或者HandlePromotionFailure设置不允许冒险，那这时候改为进行一次Full GC。</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><table>
<thead>
<tr>
<th align="center">收集器</th>
<th align="center">运行</th>
<th align="center">区域</th>
<th align="center">算法</th>
<th>目标</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Serial</td>
<td align="center">单线程</td>
<td align="center">新生代</td>
<td align="center">复制</td>
<td>响应速度</td>
</tr>
<tr>
<td align="center">Serial Old</td>
<td align="center">单线程</td>
<td align="center">老年代</td>
<td align="center">整理</td>
<td>响应速度</td>
</tr>
<tr>
<td align="center">ParNew</td>
<td align="center">多线程</td>
<td align="center">新生代</td>
<td align="center">复制</td>
<td>响应速度</td>
</tr>
<tr>
<td align="center">Parallel Scavenge</td>
<td align="center">多线程</td>
<td align="center">新生代</td>
<td align="center">复制</td>
<td>吞吐量</td>
</tr>
<tr>
<td align="center">Parallel Old</td>
<td align="center">多线程</td>
<td align="center">老年代</td>
<td align="center">整理</td>
<td>吞吐量</td>
</tr>
<tr>
<td align="center">CMS</td>
<td align="center">多线程</td>
<td align="center">老年代</td>
<td align="center">清除</td>
<td>响应速度</td>
</tr>
<tr>
<td align="center">G1</td>
<td align="center">多线程</td>
<td align="center">ALL</td>
<td align="center">整理+复制</td>
<td>响应速度</td>
</tr>
<tr>
<td align="center">ZGC</td>
<td align="center">多线程</td>
<td align="center">ALL</td>
<td align="center">复制</td>
<td>响应速度</td>
</tr>
<tr>
<td align="center">Shenandoah</td>
<td align="center">多线程</td>
<td align="center">ALL</td>
<td align="center">复制</td>
<td>响应速度<br />（原话：最小化停顿）</td>
</tr>
</tbody></table>
<h3 id="垃圾收集器详解"><a href="#垃圾收集器详解" class="headerlink" title="垃圾收集器详解"></a>垃圾收集器详解</h3><h4 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h4><p>单线程</p>
<p>适用：单CPU环境的Client模式</p>
<p><img src="http://img.sunyh512.cn/img/20210714194116.png"></p>
<h4 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h4><p>Serial收集器的多线程版本</p>
<p>适用：多CPU环境时在Server模式下与CMS配合</p>
<p><img src="http://img.sunyh512.cn/img/20210714194607.png"></p>
<h4 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h4><p>吞吐量优先</p>
<blockquote>
<p>  $吞吐量=\frac{运行用户代码时间}{运行用户代码时间+运行垃圾回收的时间}$</p>
<p>  用户代码加上垃圾收集总共耗费了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p>
</blockquote>
<p>适用：在后台运算而不需要太多交互的任务</p>
<h4 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h4><p>Serial的老年代版本</p>
<p>适用：单CPU环境下的Client模式、CMS的后备预案</p>
<p><img src="http://img.sunyh512.cn/img/20210714194116.png"></p>
<h4 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h4><p>适用：集中在互联网站或B/S系统服务端上的Java应用</p>
<h5 id="四个步骤："><a href="#四个步骤：" class="headerlink" title="四个步骤："></a>四个步骤：</h5><ul>
<li>  初始标记：仅标记一下GCRoots能直接关联到的对象，速度很快。</li>
<li>  并发标记：并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</li>
<li>  重新标记：因用户程序继续运作而导致标记产生变动的那部分对象的标记记录。</li>
<li>  并发清楚：清理删除掉标记阶段判断的已经死亡的对象。</li>
</ul>
<p><img src="http://img.sunyh512.cn/img/20210731193313.png" alt="image-20210731193204565"></p>
<ul>
<li><p><strong>增量更新</strong>（<a href="#%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0">三色标记</a>）：增量更新要破坏的是第一个条件：<code>赋值器插入了一条或多条从黑色对象到白色对象的新引用</code></p>
<p>  当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，</p>
<p>  等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。</p>
<ul>
<li><p>这可以简化理解为：</p>
<p>  黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。</p>
</li>
</ul>
</li>
</ul>
<h4 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h4><p>应用：面向服务端应用，将来替换CMS</p>
<p>G1收集器的内存结构完全区别于CMS，<strong>打破了原有的分代模型</strong>，<strong>将堆内存划分成一个个Region</strong>（1MB~32MB, 默认2048个分区），这么做的目的是在进行收集时不必在全堆范围内进行。</p>
<h5 id="四个步骤"><a href="#四个步骤" class="headerlink" title="四个步骤"></a>四个步骤</h5><ul>
<li><p>  初始标记：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAM S 指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要 停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际 并没有额外的停顿。</p>
</li>
<li><p>  并发标记：并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</p>
</li>
<li><p>  最终标记（重新标记）：因用户程序继续运作而导致标记产生变动的那部分对象的标记记录。</p>
</li>
<li><p>  筛选回收（并发清除）：清理删除掉标记阶段判断的已经死亡的对象</p>
</li>
<li><p>  <img src="http://img.sunyh512.cn/img/20210731193335.png" alt="image-20210731193333971"></p>
</li>
<li><p><strong>原始快照</strong>（<a href="#%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0">三色标记</a>）：原始快照要破坏的是第二个条件：赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</p>
<p>  当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，</p>
<p>  在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。</p>
<ul>
<li><p>这也可以简化理解为：</p>
<p>  无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。</p>
</li>
</ul>
</li>
</ul>
<h4 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h4><p>JDK 11中推出的一款低延迟垃圾回收器</p>
<p>适用：大内存低延迟服务的内存管理和回收</p>
<p>步骤：</p>
<ul>
<li>  并发的阶段：标记、转移、重定位阶段</li>
<li>  三个Stop The World阶段：初始标记、再标记、初始转移</li>
</ul>
<p>![image-20210802152124160](/Users/ghuilrei/Library/Application Support/typora-user-images/image-20210802152124160.png)</p>
<p>技术：</p>
<ul>
<li>  着色指针：着色指针是一种将信息存储在指针中的技术。（没有过多了解）</li>
<li>  读屏障技术：读屏障是JVM向应用代码插入一小段代码的技术。当应用线程从堆中读取对象引用时，就会执行这段代码。需要注意的是，仅“从堆中读取对象引用”才会触发这段代码。（没有过多了解）</li>
</ul>
<h4 id="Shenandoah"><a href="#Shenandoah" class="headerlink" title="Shenandoah"></a>Shenandoah</h4><p>只有 OpenJDK才会包含，而OracleJDK里反而不存在的收集器。</p>
<p>（“免费开源版”比“收费商业版”功能更多，这是相对罕见的状况）</p>
<h5 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h5><ul>
<li><p>  初始标记、并发标记、最终标记：这三个步骤和 G1 一样。初始标记和最终标记会造成Stop The World；并发标记阶段是垃圾回收线程和用户线程并发执行。</p>
</li>
<li><p>  并发清理：G1 中是多个 GC 线程并行清理，而 Shenandoah 中是并发清理，GC 线程和用户线程并发执行，不会造成 STW。<strong>这一步清理仅仅只是清理一个存活对象都没有的 Region。</strong></p>
</li>
<li><p>并发回收：将回收集中，所有存活的对象复制到空闲的 Region 中。</p>
<p>  在移动完存活对象后，还需要修改所有指向这些存活对象的引用指向，而这个过程很难一瞬间就改变过来。</p>
<p>  由于是并发执行，用户线程也在运行，当我们将存活对象移动到新的 Region 中时，如果引用指向还没有修改为最新的对象地址，那就可能导致程序出错。</p>
<p>  Shenandoah 为了实现并发回收，采用了<code>Brooks Pointers</code>转发指针来解决该问题。</p>
</li>
<li><p>引用更新：把堆中所有指向旧对象的地址修正为指向新地址。</p>
<ul>
<li>  初始引用更新：为了提供一个线程的集合点，确保所有的垃圾回收线程都完成了复制对象到新 Region 的任务。</li>
<li>  并发引用更新：按照内存的物理地址顺序，线性地搜索出引用类型，然后更新为新地址，这一步是和用户线程一起并发执行。</li>
<li>  最终引用更新：更新 GC Roots 中的指向旧地址的对象到新地址。</li>
</ul>
</li>
<li><p>  并发清理：将回收集中所有的 Region 清除，该过程和用户线程并发执行，不会产生 STW。</p>
</li>
</ul>
<p>G1中耗费大量内存和计算资源去维护的记忆集，改用名为“ 连接矩阵”。</p>
<h5 id="Brooks-Pointer-转发指针"><a href="#Brooks-Pointer-转发指针" class="headerlink" title="Brooks Pointer 转发指针"></a>Brooks Pointer 转发指针</h5><p>传统的对象布局中，每个对象由对象头和对象数据组成，</p>
<p>而在 Shenandoah 中改变了对象的布局，它为每个对象在对象头之前添加了一个 Brooks Pointer 转发指针，默</p>
<p>认情况下，这个转发指针指向自己，</p>
<p>当用户线程访问对象时，每次先访问的是转发指针，然后通过转发指针再去访问真实的对象。</p>
<p><img src="http://img.sunyh512.cn/img/20210802155918.png" alt="对象移动示意图"></p>
<p>总结：</p>
<ol>
<li>  新生代一般使用的复制算法，优先是效率高，缺点是内存利用率低；</li>
<li>  老生代一般使用标记-清除/标记-整理算法。</li>
</ol>
<h3 id="CMS和G1的区别"><a href="#CMS和G1的区别" class="headerlink" title="CMS和G1的区别"></a>CMS和G1的区别</h3><ul>
<li>  使用范围不一样</li>
</ul>
<p>CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用<br>G1收集器收集范围是老年代和新生代。不需要结合其他收集器使用</p>
<ul>
<li>  STW的时间</li>
</ul>
<p>CMS收集器以最小的停顿时间为目标的收集器。</p>
<p>G1收集器可预测垃圾回收的停顿时间（建立可预测的停顿时间模型）</p>
<ul>
<li>  垃圾碎片</li>
</ul>
<p>CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片</p>
<p>G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片</p>
<h3 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h3><p>标记可回收对象时，从GC Roots继续往下遍历对象图，</p>
<p>这一步骤的停顿时间就必定会与Java堆容量直接成正比例关系了，</p>
<p>堆越大，存储的对象越多，对象图结构越复杂，要标记更多对象而产生的停顿时间自然就更长。</p>
<p><strong>必须在能保障一致性的快照上才能进行对象图的遍历</strong></p>
<p>引入三色标记(Tri-color Marking)作为工具来辅助推导，</p>
<p>把遍历对象图过程中遇到的对象，按照“是否访问过”这个条件标记成以下三种颜色</p>
<ul>
<li><p>白色：表示对象尚未被垃圾收集器访问过。</p>
<p>  显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。</p>
</li>
<li><p>黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。</p>
<p>  黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接(不经过灰色对象)指向某个白色对象。</p>
</li>
<li><p>  灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。</p>
</li>
</ul>
<p><img src="http://img.sunyh512.cn/img/20210731194302.png" alt="image-20210714171302089"></p>
<p>当且仅当以下两个条件同时满足时，会产生“对象消失”的问题，</p>
<p>即原本应该是黑色的对象被误标为白色:</p>
<ul>
<li>  赋值器插入了一条或多条从黑色对象到白色对象的新引用; </li>
<li>  赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</li>
</ul>
<p>解决方案：</p>
<ul>
<li><p>增量更新(Incremental Update)</p>
<p>  增量更新要破坏的是第一个条件，</p>
<p>  当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，</p>
<p>  等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。</p>
<ul>
<li><p>这可以简化理解为：</p>
<p>  黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。</p>
</li>
</ul>
</li>
<li><p>原始快照(Snapshot At The Beginning，SATB) </p>
<p>  原始快照要破坏的是第二个条件，</p>
<p>  当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，</p>
<p>  在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。</p>
<ul>
<li><p>这也可以简化理解为：</p>
<p>  无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。</p>
</li>
</ul>
</li>
</ul>
<h2 id="内存溢出与内存泄露"><a href="#内存溢出与内存泄露" class="headerlink" title="内存溢出与内存泄露"></a>内存溢出与内存泄露</h2><p>当程序需要申请内存的时候，由于没有足够的内存，此时就会抛出<code>OutOfMemoryError</code>，这就是内存溢出。</p>
<h3 id="内存泄漏和内存溢出区别与联系"><a href="#内存泄漏和内存溢出区别与联系" class="headerlink" title="内存泄漏和内存溢出区别与联系"></a>内存泄漏和内存溢出区别与联系</h3><ul>
<li>内存泄漏：系统分配的内存无法被回收。<ul>
<li>  不一定报错。</li>
</ul>
</li>
<li>内存溢出：分配的内存空间超过系统内存。<ul>
<li>  一定报错。</li>
</ul>
</li>
</ul>
<h3 id="内存泄露的原因"><a href="#内存泄露的原因" class="headerlink" title="内存泄露的原因"></a>内存泄露的原因</h3><p>当在堆中创建了对象，后来没有使用这个对象了，又没有把整个对象的相关引用设为null。</p>
<p>此时垃圾收集器会认为这个对象是需要的，就不会清理这部分内存。</p>
<p>这就会导致这部分内存不可用。</p>
<p>所以<strong>内存泄漏</strong>会导致可用的内存减少，进而会导致<strong>内存溢出</strong>。</p>
<h3 id="内存溢出的原因"><a href="#内存溢出的原因" class="headerlink" title="内存溢出的原因"></a>内存溢出的原因</h3><p>内存溢出是由于没被引用的对象过多造成JVM没有及时回收，造成的内存溢出。</p>
<p>如果出现这种现象可行代码排查：</p>
<ul>
<li><p>是否App中的类中和引用变量过多使用了Static修饰</p>
<p>  在类中的属性中使用 static修饰的最好只用基本类型或字符串。</p>
</li>
<li><p>是否App中使用了大量的递归或无限递归</p>
<p>  递归中用到了大量的建新的对象。</p>
</li>
<li><p>是否App中使用了大量循环或死循环</p>
<p>  循环中用到了大量的新建的对象</p>
</li>
<li><p>检查App中是否使用了向数据库查询所有记录的方法。</p>
<p>  即一次性全部查询的方法，如果数据量超过10万多条了，就可能会造成内存溢出。所以在查询时应采用“分页查询”。</p>
</li>
<li><p>  检查是否有数组，List，Map中存放的是对象的引用而不是对象，因为这些引用会让对应的对象不能被释放，会大量存储在内存中。</p>
</li>
<li><p>检查是否使用了“非字面量字符串进行+”的操作。</p>
<p>  因为String类的内容是不可变的，每次运行”+”就会产生新的对象，如果过多会造成新String对象过多，从而导致JVM没有及时回收而出现内存溢出。</p>
</li>
</ul>
<h3 id="常见的内存溢出"><a href="#常见的内存溢出" class="headerlink" title="常见的内存溢出"></a>常见的内存溢出</h3><ol>
<li><p>栈内存溢出</p>
<ul>
<li>  程序所要求的栈深度过大导致。</li>
<li><strong>解决方法</strong> ：<ul>
<li>  修改程序。</li>
<li>  通过 -Xss: 来设置每个线程的Stack大小即可。</li>
</ul>
</li>
</ul>
</li>
<li><p>堆内存溢出</p>
<ul>
<li><p>分清内存泄露还是内存容量不足。</p>
<p>  泄露则看对象如何被 GC Root 引用；</p>
<p>  不足则通过调大 -Xms，-Xmx参数；</p>
</li>
<li><p>  <strong>解决方法</strong> ：手动设置JVM Heap（堆）的大小。</p>
</li>
</ul>
</li>
<li><p>持久带内存溢出</p>
<ul>
<li>  Class对象未被释放，Class对象占用信息过多，有过多的Class对象。</li>
<li>  <strong>解决方法</strong> ： 通过-XX:PermSize和-XX:MaxPermSize设置永久代大小即可。</li>
</ul>
</li>
<li><p>无法创建本地线程</p>
<ul>
<li>  总容量不变，堆内存，非堆内存设置过大，会导致能给线程的内存不足。</li>
<li><strong>解决方法：</strong><ul>
<li>  增大进程所占用的总内存。</li>
<li>  减少-Xmx或者-Xss来达到创建更多线程的目的。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="内存分配及回收策略"><a href="#内存分配及回收策略" class="headerlink" title="内存分配及回收策略"></a>内存分配及回收策略</h2><p>大部分创建的对象会在</p>
<h3 id="新生代如何进入老年代"><a href="#新生代如何进入老年代" class="headerlink" title="新生代如何进入老年代"></a>新生代如何进入老年代</h3><p>新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。</p>
<p>老年代GC（Major GC/Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。 Major GC的速度一般会比Minor GC慢10倍以上。</p>
<ul>
<li><p>对象优先在Eden分配</p>
<p>  大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次新生代GC（Minor GC）。</p>
</li>
<li><p>大对象直接进入年老代</p>
<p>  大对象即需要大量连续内存空间的Java对象，如长字符串及数组。</p>
<p>  经常出现大对象导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来安置他们。 </p>
<p>  虚拟机提供了一个-XX：PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。 这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制（新生代采用复制算法收集内存）。</p>
</li>
<li><p>长期存活的对象将进入年老代</p>
<p>  虚拟机给每个对象定义了一个对象年龄计数器，在对象在Eden创建并经过第一次Minor GC后仍然存活，并能被Suivivor容纳的话，将会被移动到Survivor空间，并对象年龄设置为1。每经历过Minor GC，年龄就增加1岁，当到一定程度（默认15岁，可以通过参数-XXMaxTenuringThreshold设置），就将会晋升年老代。</p>
</li>
<li><p>动态对象年龄判定</p>
<p>  为了更好地适应不同程序内存状况，虚拟机并不硬性要求对象年龄达到MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入年老代。</p>
</li>
<li><p>  <a href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D">空间分配担保</a></p>
</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JVM/" rel="tag"># JVM</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/08/04/JVM%E4%B9%8BHotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8E%E5%AF%B9%E8%B1%A1/" rel="prev" title="JVM之HotSpot虚拟机与对象">
                  <i class="fa fa-chevron-left"></i> JVM之HotSpot虚拟机与对象
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/08/04/JVM%E4%B9%8B%E5%8F%82%E6%95%B0%E5%92%8C%E5%B7%A5%E5%85%B7/" rel="next" title="JVM之参数和工具">
                  JVM之参数和工具 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ghuilrei</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.1.4/es5/tex-mml-chtml.js","integrity":"sha256-ncNI9OXOS5Ek4tzVYiOMmN/KKCPZ6V0Cpv2P/zHntiA="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
