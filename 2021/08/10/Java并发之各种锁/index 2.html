<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.sunyh512.cn","root":"/","images":"/images","scheme":"Gemini","version":"8.5.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>
<meta name="description" content="Java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发之各种锁">
<meta property="og:url" content="http://blog.sunyh512.cn/2021/08/10/Java%E5%B9%B6%E5%8F%91%E4%B9%8B%E5%90%84%E7%A7%8D%E9%94%81/index.html">
<meta property="og:site_name" content="Ghuilrei&#39;s Blog">
<meta property="og:description" content="Java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://img.sunyh512.cn/img/20210810152121.png">
<meta property="og:image" content="http://img.sunyh512.cn/img/20210810152209.png">
<meta property="og:image" content="http://img.sunyh512.cn/img/20210817083706.png">
<meta property="og:image" content="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/8afdf6f2.png">
<meta property="og:image" content="http://img.sunyh512.cn/img/20210817104413.png">
<meta property="og:image" content="http://img.sunyh512.cn/img/20210818162209.png">
<meta property="og:image" content="http://img.sunyh512.cn/img/20210818162212.png">
<meta property="article:published_time" content="2021-08-10T07:31:57.000Z">
<meta property="article:modified_time" content="2021-08-18T09:02:14.982Z">
<meta property="article:author" content="Ghuilrei">
<meta property="article:tag" content="Java并发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://img.sunyh512.cn/img/20210810152121.png">


<link rel="canonical" href="http://blog.sunyh512.cn/2021/08/10/Java%E5%B9%B6%E5%8F%91%E4%B9%8B%E5%90%84%E7%A7%8D%E9%94%81/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://blog.sunyh512.cn/2021/08/10/Java%E5%B9%B6%E5%8F%91%E4%B9%8B%E5%90%84%E7%A7%8D%E9%94%81/","path":"2021/08/10/Java并发之各种锁/","title":"Java并发之各种锁"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java并发之各种锁 | Ghuilrei's Blog</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Ghuilrei's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
        <li class="menu-item menu-item-schedule"><a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">1.</span> <span class="nav-text">锁的分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lock%E3%80%81AQS%E3%80%81%E9%94%81%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">2.</span> <span class="nav-text">Lock、AQS、锁之间的关系</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Lock%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.1.</span> <span class="nav-text">Lock接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS%E5%8E%9F%E7%90%86"><span class="nav-number">2.2.</span> <span class="nav-text">AQS原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#AQS-%E5%AF%B9%E8%B5%84%E6%BA%90%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F"><span class="nav-number">2.2.1.</span> <span class="nav-text">AQS 对资源的共享方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%8B%AC%E5%8D%A0"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">独占</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">共享</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81-amp-%E6%82%B2%E8%A7%82%E9%94%81"><span class="nav-number">3.</span> <span class="nav-text">乐观锁 &amp; 悲观锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81"><span class="nav-number">3.1.</span> <span class="nav-text">乐观锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%82%B2%E8%A7%82%E9%94%81"><span class="nav-number">3.2.</span> <span class="nav-text">悲观锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">3.3.</span> <span class="nav-text">适用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">3.4.</span> <span class="nav-text">实现方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81-amp-%E9%80%82%E5%BA%94%E6%80%A7%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-number">4.</span> <span class="nav-text">自旋锁 &amp; 适应性自旋锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-number">4.1.</span> <span class="nav-text">自旋锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%82%E5%BA%94%E6%80%A7%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-number">4.2.</span> <span class="nav-text">适应性自旋锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A0%E9%94%81-amp-%E5%81%8F%E5%90%91%E9%94%81-amp-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81-amp-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="nav-number">5.</span> <span class="nav-text">无锁 &amp; 偏向锁 &amp; 轻量级锁 &amp; 重量级锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="nav-number">5.1.</span> <span class="nav-text">Java对象头</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Monitor"><span class="nav-number">5.2.</span> <span class="nav-text">Monitor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E8%AF%A6%E6%83%85"><span class="nav-number">5.3.</span> <span class="nav-text">锁详情</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E9%94%81"><span class="nav-number">5.3.1.</span> <span class="nav-text">无锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="nav-number">5.3.2.</span> <span class="nav-text">偏向锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="nav-number">5.3.3.</span> <span class="nav-text">轻量级锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="nav-number">5.3.4.</span> <span class="nav-text">重量级锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E5%8D%87%E7%BA%A7%E4%B8%8E%E5%AF%B9%E6%AF%94"><span class="nav-number">5.3.5.</span> <span class="nav-text">锁的升级与对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="nav-number">5.3.6.</span> <span class="nav-text">对象头</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81-amp-%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="nav-number">6.</span> <span class="nav-text">公平锁 &amp; 非公平锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81"><span class="nav-number">6.1.</span> <span class="nav-text">公平锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="nav-number">6.2.</span> <span class="nav-text">非公平锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantLock"><span class="nav-number">6.3.</span> <span class="nav-text">ReentrantLock</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81-amp-%E9%9D%9E%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="nav-number">7.</span> <span class="nav-text">可重入锁 &amp; 非可重入锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">7.1.</span> <span class="nav-text">原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8B%AC%E4%BA%AB%E9%94%81-amp-%E5%85%B1%E4%BA%AB%E9%94%81"><span class="nav-number">8.</span> <span class="nav-text">独享锁 &amp; 共享锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8B%AC%E4%BA%AB%E9%94%81"><span class="nav-number">8.1.</span> <span class="nav-text">独享锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81"><span class="nav-number">8.2.</span> <span class="nav-text">共享锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantReadWriteLock"><span class="nav-number">8.3.</span> <span class="nav-text">ReentrantReadWriteLock</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99%E9%94%81%E7%9A%84%E5%8A%A0%E9%94%81%E6%BA%90%E7%A0%81"><span class="nav-number">8.3.1.</span> <span class="nav-text">写锁的加锁源码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E9%94%81%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="nav-number">8.3.2.</span> <span class="nav-text">读锁的代码</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ghuilrei"
      src="http://img.sunyh512.cn/img/20210803143027.jpeg">
  <p class="site-author-name" itemprop="name">Ghuilrei</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">38</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



          </div>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://blog.sunyh512.cn/2021/08/10/Java%E5%B9%B6%E5%8F%91%E4%B9%8B%E5%90%84%E7%A7%8D%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.sunyh512.cn/img/20210803143027.jpeg">
      <meta itemprop="name" content="Ghuilrei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ghuilrei's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java并发之各种锁
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-10 15:31:57" itemprop="dateCreated datePublished" datetime="2021-08-10T15:31:57+08:00">2021-08-10</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-08-18 17:02:14" itemprop="dateModified" datetime="2021-08-18T17:02:14+08:00">2021-08-18</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E4%BD%93%E7%B3%BB/" itemprop="url" rel="index"><span itemprop="name">Java体系</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E4%BD%93%E7%B3%BB/%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">并发</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>Java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。</p>
<span id="more"></span>

<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2018/11/15/java-lock.html">https://tech.meituan.com/2018/11/15/java-lock.html</a></p>
<h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><p><img src="http://img.sunyh512.cn/img/20210810152121.png" alt="Java主流锁"></p>
<h2 id="Lock、AQS、锁之间的关系"><a href="#Lock、AQS、锁之间的关系" class="headerlink" title="Lock、AQS、锁之间的关系"></a>Lock、AQS、锁之间的关系</h2><p>Java 5之后新增了Lock接口，自定义类可实现Lock接口，并通过内部静态类继承AQS抽象类的方式实现独占锁、共享锁。</p>
<p><strong>锁是面向使用者的，它定义了使用者与锁交互的接口，隐藏了实现细节；</strong></p>
<p><strong>同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作</strong>。</p>
<p>用户调用子类实现的Lock接口中提供的方法，而这些方法又调用同步器的方法来实现具体的功能。</p>
<p>AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器。</p>
<h3 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h3><p>Lock接口（以及相关实现类）用来实现锁功能，它提供了与<code>synchronized</code>关键字类似的同步功能，只是在使用时需要显式地获取和释放锁。</p>
<p>虽然它缺少了（通过<code>synchronized</code>块或者方法提供的）隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断的获取锁以及超时获取锁等多种<code>synchronized</code>关键字所不具备的同步特性。</p>
<p>相比于<code>synchronized</code>，<code>Lock接口</code>所具备的其他特性：</p>
<ul>
<li>**尝试非阻塞地获取锁<code>tryLock()</code>**：当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁</li>
<li>**能被中断地获取锁<code>lockInterruptibly()</code>**：与synchronized不同，获取到锁的线程能够响应中断，当获取到锁地线程被中断时，中断异常将会被抛出，同时锁会被释放</li>
<li>**超时获取锁<code>tryLock(long time, TimeUnit unit)</code>**：在指定地截至时间之前获取锁，如果截至时间到了仍旧无法获取锁，则返回</li>
</ul>
<h3 id="AQS原理"><a href="#AQS原理" class="headerlink" title="AQS原理"></a>AQS原理</h3><p>核心思想：</p>
<p>如果被请求的共享资源空闲，则将当前请求资源的线程设置位有效的工作线程，并且将共享资源设置为锁定状态。</p>
<p>如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，</p>
<p>这个机制AQS是从CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p>
<blockquote>
<p>CLH队列是一个双向队列（虚拟的双向队列即不存在队列实例，仅存在节点之间的关联关系）。</p>
<p>AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个节点（Node）来实现锁的分配。</p>
</blockquote>
<p><img src="http://img.sunyh512.cn/img/20210810152209.png" alt="AQS原理图"></p>
<p>AQS 使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//共享变量，使用volatile修饰保证线程可见性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure>

<p>状态信息通过 protected 类型的<code>getState()</code>，<code>setState()</code>，<code>compareAndSetState()</code>进行操作</p>
<h4 id="AQS-对资源的共享方式"><a href="#AQS-对资源的共享方式" class="headerlink" title="AQS 对资源的共享方式"></a>AQS 对资源的共享方式</h4><ul>
<li>  Exclusive（独占）</li>
<li>  Share（共享）</li>
</ul>
<h5 id="独占"><a href="#独占" class="headerlink" title="独占"></a>独占</h5><p>只有一个线程能执行，如ReentrantLock。</p>
<p>又可分为公平锁和非公平锁，ReentrantLock 同时支持两种锁，</p>
<p>下面以 ReentrantLock 对这两种锁的定义做介绍：</p>
<ul>
<li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁。</li>
<li>非公平锁：当线程要获取锁时，先通过两次 CAS 操作去抢锁，如果没抢到，当前线程再加入到队列中等待唤醒。</li>
</ul>
<p>公平锁和非公平锁只有两处不同：</p>
<ol>
<li>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</li>
<li>非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。</li>
</ol>
<p>公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。</p>
<p>相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</p>
<h5 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h5><p>多个线程可同时执行，如 <code>Semaphore</code>/<code>CountDownLatch</code>。</p>
<p><code>ReentrantReadWriteLock</code>可以看成是组合式，因为<code>ReentrantReadWriteLock</code>也就是读写锁允许多个线程同时对某一资源进行读。</p>
<p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS 已经在上层已经帮我们实现好了。</p>
<h2 id="乐观锁-amp-悲观锁"><a href="#乐观锁-amp-悲观锁" class="headerlink" title="乐观锁 &amp; 悲观锁"></a>乐观锁 &amp; 悲观锁</h2><p>乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。</p>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>对于数据的并发操作，乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。</p>
<ul>
<li>  如果这个数据没有被更新，当前线程将自己修改的数据成功写入。</li>
<li>  如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。</li>
</ul>
<p>乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。</p>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>对于数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。</p>
<p>Java中，synchronized关键字和Lock的实现类都是悲观锁。</p>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li>  悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。</li>
<li>  乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。</li>
</ul>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ------------------------- 悲观锁的调用方式 -------------------------</span></span><br><span class="line"><span class="comment">// synchronized</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 操作同步资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReentrantLock</span></span><br><span class="line"><span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">// 需要保证多个线程使用的是同一个锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyPublicResources</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	lock.lock();</span><br><span class="line">	<span class="comment">// 操作同步资源</span></span><br><span class="line">	lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------- 乐观锁的调用方式 -------------------------</span></span><br><span class="line"><span class="comment">// 需要保证多个线程使用的是同一个AtomicInteger</span></span><br><span class="line"><span class="keyword">private</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(); </span><br><span class="line">atomicInteger.incrementAndGet(); <span class="comment">//执行自增1</span></span><br></pre></td></tr></table></figure>

<h2 id="自旋锁-amp-适应性自旋锁"><a href="#自旋锁-amp-适应性自旋锁" class="headerlink" title="自旋锁 &amp; 适应性自旋锁"></a>自旋锁 &amp; 适应性自旋锁</h2><p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p>
<p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</p>
<p>而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p><img src="http://img.sunyh512.cn/img/20210817083706.png" alt="img"></p>
<p>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。</p>
<p>如果锁被占用的时间很短，自旋等待的效果就会非常好。</p>
<p>反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。</p>
<p>所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。</p>
<p>自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p>
<h3 id="适应性自旋锁"><a href="#适应性自旋锁" class="headerlink" title="适应性自旋锁"></a>适应性自旋锁</h3><p>自旋锁在JDK1.4.2中引入，使用<code>-XX:+UseSpinning</code>来开启。JDK 6中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。</p>
<p>自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p>
<p>如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。</p>
<p>如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p>
<p>在自旋锁中另有三种常见的锁形式：TicketLock、CLHlock和MCSlock</p>
<h2 id="无锁-amp-偏向锁-amp-轻量级锁-amp-重量级锁"><a href="#无锁-amp-偏向锁-amp-轻量级锁-amp-重量级锁" class="headerlink" title="无锁 &amp; 偏向锁 &amp; 轻量级锁 &amp; 重量级锁"></a>无锁 &amp; 偏向锁 &amp; 轻量级锁 &amp; 重量级锁</h2><h3 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a><a href="2021/08/04/JVM%E4%B9%8BHotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8E%E5%AF%B9%E8%B1%A1/#%E5%AF%B9%E8%B1%A1%E5%A4%B4">Java对象头</a></h3><p>synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就存在Java对象头里。</p>
<p>我们以Hotspot虚拟机为例，Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。</p>
<ul>
<li>  <strong>Mark Word</strong>：默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。</li>
<li>  <strong>Klass Point</strong>：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li>
</ul>
<h3 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h3><p>Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。</p>
<p>Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p>
<hr>
<p>现在话题回到<code>synchronized</code>，<code>synchronized</code>通过<code>Monitor</code>来实现线程同步，<code>Monitor</code>是依赖于底层的操作系统的<code>Mutex Lock（互斥锁）</code>来实现的线程同步。</p>
<p>如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长”。</p>
<p>这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。</p>
<p>这种依赖于操作系统Mutex Lock所实现的锁我们称之为“<strong>重量级锁</strong>”，JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“<strong>偏向锁</strong>”和“<strong>轻量级锁</strong>”。</p>
<p>所以目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。<strong>锁状态只能升级不能降级。</strong></p>
<h3 id="锁详情"><a href="#锁详情" class="headerlink" title="锁详情"></a>锁详情</h3><h4 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h4><p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p>
<p>无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。</p>
<p>如果没有冲突就修改成功并退出，否则就会继续循环尝试。</p>
<p>如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。</p>
<p>上面我们介绍的CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。</p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。</p>
<p>在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。</p>
<p>当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。</p>
<p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p>
<p>偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。</p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p>
<p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。</p>
<p>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。</p>
<p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。</p>
<p>如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。</p>
<p>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。</p>
<h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。</p>
<h4 id="锁的升级与对比"><a href="#锁的升级与对比" class="headerlink" title="锁的升级与对比"></a><a href="2021/08/05/Java%E5%B9%B6%E5%8F%91%E4%B9%8B%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/#%E9%94%81%E7%9A%84%E5%8D%87%E7%BA%A7%E4%B8%8E%E5%AF%B9%E6%AF%94">锁的升级与对比</a></h4><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/8afdf6f2.png" alt="锁升级"></p>
<h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><table>
<thead>
<tr>
<th align="left">锁状态</th>
<th align="left">存储内容</th>
<th align="left">存储内容</th>
</tr>
</thead>
<tbody><tr>
<td align="left">无锁</td>
<td align="left">对象的hashCode、对象分代年龄、是否是偏向锁（0）</td>
<td align="left">01</td>
</tr>
<tr>
<td align="left">偏向锁</td>
<td align="left">偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1）</td>
<td align="left">01</td>
</tr>
<tr>
<td align="left">轻量级锁</td>
<td align="left">指向栈中锁记录的指针</td>
<td align="left">00</td>
</tr>
<tr>
<td align="left">重量级锁</td>
<td align="left">指向互斥量（重量级锁）的指针</td>
<td align="left">10</td>
</tr>
</tbody></table>
<h2 id="公平锁-amp-非公平锁"><a href="#公平锁-amp-非公平锁" class="headerlink" title="公平锁 &amp; 非公平锁"></a>公平锁 &amp; 非公平锁</h2><h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。</p>
<ul>
<li><p>  优点是等待锁的线程不会饿死。</p>
</li>
<li><p>  缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p>
</li>
</ul>
<h3 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h3><p>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。</p>
<ul>
<li><p>  优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。</p>
</li>
<li><p>  缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p>
</li>
</ul>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p><code>ReentrantLock</code>里面有一个内部类<code>Sync</code>，<code>Sync</code>继承<code>AQS</code>（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在<code>Sync</code>中实现的。</p>
<p>它有公平锁<code>FairSync</code>和非公平锁<code>NonfairSync</code>两个子类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantLock默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">	sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过下图可以看出公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：<code>hasQueuedPredecessors()</code>。</p>
<p><img src="http://img.sunyh512.cn/img/20210817104413.png" alt="ReentrantLock中公平锁与非公平锁的代码差异"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询是否有线程等待获取的时间超过当前线程。</span></span><br><span class="line"><span class="comment">// 实际上主要是判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = tail;</span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t 									<span class="comment">// 有等待的线程</span></span><br><span class="line">        &amp;&amp; (										<span class="comment">// 并且</span></span><br><span class="line">            (s = h.next) == <span class="keyword">null</span> 					<span class="comment">// 头节点没有下一个节点</span></span><br><span class="line">            || s.thread != Thread.currentThread()	<span class="comment">// 或者头节点线程不是当前线程</span></span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="可重入锁-amp-非可重入锁"><a href="#可重入锁-amp-非可重入锁" class="headerlink" title="可重入锁 &amp; 非可重入锁"></a>可重入锁 &amp; 非可重入锁</h2><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。</p>
<p>如<code>synchronized</code>、<code>ReentrantLock</code>。</p>
<p>某个线程已经获得某个锁，可以<strong>再次获得锁而不会出现死锁</strong>。</p>
<p><code>ReentrantLoock</code>和<code>synchronzied</code>不一样，需要手动释放锁，所以使用ReentrantLock地时候一定要手动释放锁，并且加锁次数和释放次数要一样。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>首先<code>ReentrantLock</code>和<code>NonReentrantLock</code>都继承父类<code>AQS</code>，其父类<code>AQS</code>中维护了一个同步状态<code>status</code>来计数重入次数，<code>status</code>初始值为0。</p>
<p>当线程尝试获取锁时，可重入锁先尝试获取并更新status值：</p>
<ul>
<li>  如果<code>status == 0</code>表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。</li>
<li>如果<code>status != 0</code>则判断当前线程是否是获取到这个锁的线程：<ul>
<li>  如果是的话执行<code>status+1</code>，且当前线程可以再次获取锁。</li>
</ul>
</li>
</ul>
<p><em>非可重入锁是直接去获取并尝试更新当前status的值，如果status != 0的话会导致其获取锁失败，当前线程阻塞。</em></p>
<p>释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。</p>
<ul>
<li>  如果<code>status-1 == 0</code>，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。</li>
</ul>
<p><em>而非可重入锁则是在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放。</em></p>
<h2 id="独享锁-amp-共享锁"><a href="#独享锁-amp-共享锁" class="headerlink" title="独享锁 &amp; 共享锁"></a>独享锁 &amp; 共享锁</h2><p>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</p>
<h3 id="独享锁"><a href="#独享锁" class="headerlink" title="独享锁"></a>独享锁</h3><p>独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。</p>
<p>如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。</p>
<p>获得排它锁的线程即能读数据又能修改数据。</p>
<p>JDK 中的<code>synchronized</code>和 JUC (<code>java.util.concurrent</code>) 中<code>Lock</code>的实现类就是互斥锁。</p>
<h3 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h3><p>共享锁是指该锁可被多个线程所持有。</p>
<p>如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。</p>
<p>获得共享锁的线程只能读数据，不能修改数据。</p>
<h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p>我们看到<code>ReentrantReadWriteLock</code>有两把锁：<code>ReadLock</code>和<code>WriteLock</code>，由词知意，一个读锁一个写锁，合称“读写锁”。<code>ReadLock</code>和<code>WriteLock</code>是靠内部类Sync实现的锁。</p>
<p>在<code>ReentrantReadWriteLock</code>里面，读锁和写锁的锁主体都是Sync，但读锁和写锁的加锁方式不一样。</p>
<p><strong>读锁是共享锁，写锁是独享锁。</strong></p>
<p>读锁的共享锁可保证<code>并发读</code>非常高效，而<code>读写</code>、<code>写读</code>、<code>写写</code>的过程互斥，因为读锁和写锁是分离的。</p>
<p>所以<code>ReentrantReadWriteLock</code>的并发性相比一般的互斥锁有了很大提升。</p>
<p>在最开始提及AQS的时候我们也提到了state字段（int类型，32位），该字段用来描述有多少线程获持有锁。</p>
<p>在独享锁中这个值通常是0或者1（如果是重入锁的话state值就是重入的次数），在共享锁中state就是持有锁的数量。</p>
<p>但是在<code>ReentrantReadWriteLock</code>中有读、写两把锁，所以需要在一个整型变量state上分别描述读锁和写锁的数量（或者也可以叫状态）。</p>
<p>于是将state变量“按位切割”切分成了两个部分，高16位表示读锁状态（读锁个数），低16位表示写锁状态（写锁个数）。</p>
<p><img src="http://img.sunyh512.cn/img/20210818162209.png" alt="state变量划分结构"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 划分高16位和低16位</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 左移16位后减1:16位二进制1</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 获取c（state）的低16位：写锁个数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="写锁的加锁源码"><a href="#写锁的加锁源码" class="headerlink" title="写锁的加锁源码"></a>写锁的加锁源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 介绍:</span></span><br><span class="line"><span class="comment"> * 1. 如果读计数器非零或写计数器非零且所有者是不同的线程，则失败。</span></span><br><span class="line"><span class="comment"> * 2. 如果计数饱和，则失败。(这只会在count已经非零的情况下发生。)</span></span><br><span class="line"><span class="comment"> * 3. 否则，如果可重入获取或队列策略允许，则该线程有资格获得锁。如果是，请更新状态并设置所有者。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">	Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 取到当前锁的个数</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 取 写锁的个数w</span></span><br><span class="line">	<span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> (c != <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="comment">// c!=0：如果已经有线程持有了锁（已经有其他线程获取了读锁或写锁）</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="comment">// 如果写线程数（w）为0（换言之存在读锁）或者持有锁的线程不是当前线程就返回失败</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="comment">// 如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">// Reentrant acquire</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() || !compareAndSetState(c, c + acquires)) </span><br><span class="line">        <span class="comment">// 如果当且写线程数为0，并且当前线程需要阻塞那么就返回失败；</span></span><br><span class="line">        <span class="comment">// 或者如果通过CAS增加写线程数失败也返回失败。</span></span><br><span class="line">        <span class="comment">// writerShouldBlock()：如果当前线程在试图获得写锁时，或者符合条件获得写锁的情况下，由于超过其他等待线程的策略而阻塞，则返回true。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果c=0，w=0或者c&gt;0，w&gt;0（重入），则设置当前线程或锁的拥有者</span></span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://img.sunyh512.cn/img/20210818162212.png" alt="img"></p>
<h4 id="读锁的代码"><a href="#读锁的代码" class="headerlink" title="读锁的代码"></a>读锁的代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 介绍:</span></span><br><span class="line"><span class="comment"> * 1. 如果写锁被另一个线程持有，则失败。</span></span><br><span class="line"><span class="comment"> * 2. 否则，该线程有资格进入锁，因此询问它是否应该因为队列策略而阻塞。</span></span><br><span class="line"><span class="comment"> * 	如果没有，尝试通过套管状态和更新计数授予。</span></span><br><span class="line"><span class="comment"> * 	注意，步骤不检查可重入获取，这被推迟到完整版本，以避免在更典型的不可重入情况下必须检查持有计数。</span></span><br><span class="line"><span class="comment"> * 3.如果第2步失败，要么是因为线程明显不合格，要么是因为CAS失败或计数饱和，那么使用完整的重试循环链接到版本。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 1. 如果写锁已经被获取并且获取写锁的线程不是当前线程的话，当前线程获取读锁失败返回-1</span></span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp; getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 如果当前线程不需要阻塞（读锁是否需要等待：公平锁原则）</span></span><br><span class="line">    <span class="comment">// 	&amp;&amp; count中表示的共享持有项的数量没有超过最大数量（读线程数量没有超过最大数量）</span></span><br><span class="line">    <span class="comment">// 	&amp;&amp; 当前线程获取读锁</span></span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp; r &lt; MAX_COUNT &amp;&amp; compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// r == 0，表示第一个读锁线程，第一个读锁firstRead是不会加入到readHolds中</span></span><br><span class="line">            <span class="comment">// 将第一个线程设置为当前线程</span></span><br><span class="line">            firstReader = current;</span><br><span class="line">            <span class="comment">// 读线程占用的资源数为1</span></span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            <span class="comment">// 当前线程为第一个读线程，表示第一个读锁线程重入</span></span><br><span class="line">            <span class="comment">// 读线程占用的资源数+1</span></span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取计数器</span></span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                <span class="comment">// 计数器为空或者计数器的tid不为当前正在运行的线程的tid，获取当前线程对应的计数器</span></span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 加入到readHolds中</span></span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java%E5%B9%B6%E5%8F%91/" rel="tag"># Java并发</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/08/06/Java%E5%B9%B6%E5%8F%91%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" rel="prev" title="Java并发之JMM内存模型">
                  <i class="fa fa-chevron-left"></i> Java并发之JMM内存模型
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/08/10/Java%E5%B9%B6%E5%8F%91%E4%B9%8B%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/" rel="next" title="Java并发之并发容器">
                  Java并发之并发容器 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ghuilrei</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.1.4/es5/tex-mml-chtml.js","integrity":"sha256-ncNI9OXOS5Ek4tzVYiOMmN/KKCPZ6V0Cpv2P/zHntiA="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
